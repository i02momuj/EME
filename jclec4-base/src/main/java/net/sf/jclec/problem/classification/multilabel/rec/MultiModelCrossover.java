package net.sf.jclec.problem.classification.multilabel.rec;

import net.sf.jclec.binarray.BinArrayIndividual;
import net.sf.jclec.binarray.BinArrayRecombinator;


public class MultiModelCrossover extends BinArrayRecombinator
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = 3835150645048325173L;	
	
	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////

	private int numberLabels;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */
	
	public MultiModelCrossover() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	public void setNumberLabels(int numberLabels) {
		this.numberLabels = numberLabels;
	}

	/**
	 * {@inheritDoc}
	 */
	
	@Override
	public boolean equals(Object other)
	{
		if (other instanceof MultiModelCrossover) {
			return true;
		}
		else {
			return false;
		}
	}	

	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////

	/**
	 * {@inheritDoc}
	 */

	@Override
	protected void recombineNext() 
	{
		// Parents conversion
		BinArrayIndividual p0 = (BinArrayIndividual) parentsBuffer.get(parentsCounter);
		BinArrayIndividual p1 = (BinArrayIndividual) parentsBuffer.get(parentsCounter+1);
		// Parents genotypes
		byte [] p0_genome = p0.getGenotype();
		byte [] p1_genome = p1.getGenotype();
		int gl = p0_genome.length;
		// Creating sons genotypes
		byte [] s0_genome = new byte[gl];
		byte [] s1_genome = new byte[gl];
		// Taking a number of models
		int nModels;
		nModels = randgen.choose(0, (gl/numberLabels)-1);
		
		// Taking a origin point
		int pModel;
		do{
			pModel = randgen.choose(0, (gl/numberLabels)-1);
		}while((pModel+nModels)>(gl/numberLabels)-1);
		
		for(int i = 0; i < (gl/numberLabels); i++)
		{
			if(i == pModel)
			{
				System.arraycopy(p1_genome, pModel*numberLabels,   s0_genome, i*numberLabels,  nModels*numberLabels);
				System.arraycopy(p0_genome, pModel*numberLabels,   s1_genome, i*numberLabels,  nModels*numberLabels);
				i=i+nModels-1;
			}
			else
			{
				System.arraycopy(p0_genome, i*numberLabels,   s0_genome, i*numberLabels,  numberLabels);
				System.arraycopy(p1_genome, i*numberLabels,   s1_genome, i*numberLabels,  numberLabels);
			}
		}
		////TODO Comprobar que el modelo no se repite
		
		// Put sons in buffer
		sonsBuffer.add(species.createIndividual(s0_genome));
		sonsBuffer.add(species.createIndividual(s1_genome));
	}
}